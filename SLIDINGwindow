// 	Longest Substring Without Repeating Characters
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int max = 0;
        int left = 0;
        for (int right = 0; right < s.length(); right++) {
            while (set.contains(s.charAt(right))) {
                set.remove(s.charAt(left));
                left++;
            }
            set.add(s.charAt(right));
            max = Math.max(max, right - left + 1);
        }
        return max;

    }
}

// 1004. Max Consecutive Ones III
class Solution {
    public int longestOnes(int[] nums, int k) {
        int max =0;
        int zero =0;
        int l = 0 , r = 0 ;
        while(r < nums.length ){
            if(nums[r] == 0) zero++;

            if(zero>k){
                if(nums[l] == 0 ) zero--;
                l++;
            }
            
            if(zero <= k){
                int length = r - l + 1 ;
                max = Math.max(max, length);
            }
            r++;
        }
        return max;

    }
}

//904. Fruit Into Baskets
class Solution {
    public int totalFruit(int[] fruits) {
     Map<Integer ,Integer> map = new HashMap<>();
     int l = 0  , max =0 ;
     for(int r =0 ; r < fruits.length ; r++){
        map.put(fruits[r],map.getOrDefault(fruits[r],0)+1);
        while(map.size()>2){
            map.put(fruits[l],map.get(fruits[l])-1);
            if(map.get(fruits[l]) == 0 ) {map.remove(fruits[l]);}
            l++;
        }
        max = Math.max(max, r-l+1);
     } 
     return max;
    }
}

//424. Longest Repeating Character Replacement
class Solution {
    public int characterReplacement(String s, int k) {
        int l = 0 , maxfq = 0 ;
        int fq[] = new int[26];
        int maxwindow = 0;
        for(int r =0 ; r <s.length() ; r++){
            fq[s.charAt(r)-'A']++; // current elm ko update
            maxfq =Math.max(maxfq , fq[s.charAt(r)-'A']);

            int window = r - l + 1;
            if( ( window - maxfq ) > k){
                fq[s.charAt(l)-'A']--;
                l++;
            }
            maxwindow = Math.max(maxwindow,r-l+1);
            
        }
        return maxwindow;
        
    }
}

// 930. Binary Subarrays With Sum
class Solution {
    public int numSubarraysWithSum(int[] nums, int goal) {
        return atMost(nums, goal) - atMost(nums, goal - 1);
    }

    private int atMost(int[] nums, int goal) {
        if (goal < 0) return 0;

        int l = 0, sum = 0, count = 0;

        for (int r = 0; r < nums.length; r++) {
            sum += nums[r];

            while (sum > goal) {
                sum -= nums[l];
                l++;
            }

            count += (r - l + 1);
        }
        return count;
    }
}

//1248. Count Number of Nice Subarrays
class Solution {
    public int numberOfSubarrays(int[] nums, int k) {
        return atmost(nums , k ) - atmost(nums , k-1);
    }

    private int atmost(int nums [] , int k){
        int l=0 , count = 0, odd= 0 ;

        for(int r =0 ; r<nums.length ; r++){
            if(nums[r] %2 == 1 ) odd++;

            while(odd > k){
                if(nums[l]%2 == 1 ) {odd--;}
                l++;
            }
            count+= (r-l+1);
        }
        return count;
    }
}

//1358. Number of Substrings Containing All Three Characters
class Solution {
    public int numberOfSubstrings(String s) {
        int[] freq = new int[3]; // a, b, c
        int l = 0, count = 0;
        int n = s.length();

        for (int r = 0; r < n; r++) {
            freq[s.charAt(r) - 'a']++;

            while (freq[0] > 0 && freq[1] > 0 && freq[2] > 0) {
                count += (n - r);
                freq[s.charAt(l) - 'a']--;
                l++;
            }
        }
        return count;
    }
}
//423. Maximum Points You Can Obtain from Cards
class Solution {
    public int maxScore(int[] cardPoints, int k) {
        int lsum = 0, rsum = 0 , maxsum=0 , rindex =cardPoints.length - 1;
        for(int i = 0 ; i < k ;i++){
            lsum = lsum + cardPoints[i];
            maxsum = lsum;
        }
        for(int i = k-1 ; i>= 0 ; i--){
            lsum= lsum - cardPoints[i];
            rsum = rsum + cardPoints[rindex];
            rindex = rindex -1 ;
            maxsum = Math.max(maxsum,lsum+rsum);
        }
        return maxsum ;
    }
}

//Longest Substring with K Uniques
class Solution {
    public int longestKSubstr(String s, int k) {
        int l = 0, max = -1;
        Map<Character, Integer> map = new HashMap<>();

        for (int r = 0; r < s.length(); r++) {
            map.put(s.charAt(r), map.getOrDefault(s.charAt(r), 0) + 1);

            while (map.size() > k) {
                map.put(s.charAt(l), map.get(s.charAt(l)) - 1);
                if (map.get(s.charAt(l)) == 0) {
                    map.remove(s.charAt(l));
                }
                l++;
            }

            // âœ… EXACTLY k distinct
            if (map.size() == k) {
                max = Math.max(max, r - l + 1);
            }
        }

        return max;
    }
}
// 992. Subarrays with K Different Integers
class Solution {
    public int subarraysWithKDistinct(int[] nums, int k) {
        return helper (nums, k) - helper(nums , k-1) ;
    }
    private int helper(int nums[] , int k){
        int l =0 , count =0 ;
        Map<Integer ,Integer > map = new HashMap<>();
        for(int i = 0 ; i < nums.length ; i ++){
            map.put(nums[i] , map.getOrDefault(nums[i],0)+1);

            while(map.size() > k){
                map.put(nums[l],map.get(nums[l])-1);
                if(map.get(nums[l])==0) map.remove(nums[l]);
                l++;
            }

            count+= i-l+1;
        }
        return count;
    }
}

//76. Minimum Window Substring
class Solution {
    public String minWindow(String s, String t) {
        int hash[] = new int [128];
        // initilaze
        for(char ch : t.toCharArray()){
            hash[ch]++;
        }
        // varible
        int st=0 , l = 0  , min = Integer.MAX_VALUE , cnt =0 , m =t.length();
        // base travrse
        for(int r=0 ; r < s.length() ; r++){
            if(hash[s.charAt(r)]>0){
                cnt++;
            }
            hash[s.charAt(r)]--;

            //shriking
            while(cnt == m){
                if(r-l+1 < min){
                    min = r-l+1;
                    st = l;
                }
                hash[s.charAt(l)]++;
                if( hash[s.charAt(l)] >0){
                    cnt =cnt-1;
                }
                l++;
            }
        }
        return  min== Integer.MAX_VALUE ? "" :  s.substring(st, st + min);
    }
}

// Minimum Window Subsequence
class Solution {
    public String minWindow(String s, String t) {

        int n = s.length();
        int m = t.length();

        int minLen = Integer.MAX_VALUE;
        int start = -1;

        int i = 0;

        while (i < n) {
            int j = 0;

            // ---------- Forward scan ----------
            while (i < n) {
                if (s.charAt(i) == t.charAt(j)) {
                    j++;
                    if (j == m) break;
                }
                i++;
            }

            // agar t poora match hi nahi hua
            if (j < m) break;

            // ---------- Backward shrink ----------
            int end = i;
            j = m - 1;

            while (i >= 0) {
                if (s.charAt(i) == t.charAt(j)) {
                    j--;
                    if (j < 0) break;
                }
                i--;
            }

            // window update
            int currLen = end - i;
            if (currLen < minLen) {
                minLen = currLen;
                start = i + 1;
            }

            // next search start
            i = start + 1;
        }

        return start == -1 ? "" : s.substring(start, start + minLen);
    }
}
