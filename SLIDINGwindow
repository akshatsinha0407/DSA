// 	Longest Substring Without Repeating Characters
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> set = new HashSet<>();
        int max = 0;
        int left = 0;
        for (int right = 0; right < s.length(); right++) {
            while (set.contains(s.charAt(right))) {
                set.remove(s.charAt(left));
                left++;
            }
            set.add(s.charAt(right));
            max = Math.max(max, right - left + 1);
        }
        return max;

    }
}

// 1004. Max Consecutive Ones III
class Solution {
    public int longestOnes(int[] nums, int k) {
        int max =0;
        int zero =0;
        int l = 0 , r = 0 ;
        while(r < nums.length ){
            if(nums[r] == 0) zero++;

            if(zero>k){
                if(nums[l] == 0 ) zero--;
                l++;
            }
            
            if(zero <= k){
                int length = r - l + 1 ;
                max = Math.max(max, length);
            }
            r++;
        }
        return max;

    }
}

//904. Fruit Into Baskets
class Solution {
    public int totalFruit(int[] fruits) {
     Map<Integer ,Integer> map = new HashMap<>();
     int l = 0  , max =0 ;
     for(int r =0 ; r < fruits.length ; r++){
        map.put(fruits[r],map.getOrDefault(fruits[r],0)+1);
        while(map.size()>2){
            map.put(fruits[l],map.get(fruits[l])-1);
            if(map.get(fruits[l]) == 0 ) {map.remove(fruits[l]);}
            l++;
        }
        max = Math.max(max, r-l+1);
     } 
     return max;
    }
}

//424. Longest Repeating Character Replacement
class Solution {
    public int characterReplacement(String s, int k) {
        int l = 0 , maxfq = 0 ;
        int fq[] = new int[26];
        int maxwindow = 0;
        for(int r =0 ; r <s.length() ; r++){
            fq[s.charAt(r)-'A']++; // current elm ko update
            maxfq =Math.max(maxfq , fq[s.charAt(r)-'A']);

            int window = r - l + 1;
            if( ( window - maxfq ) > k){
                fq[s.charAt(l)-'A']--;
                l++;
            }
            maxwindow = Math.max(maxwindow,r-l+1);
            
        }
        return maxwindow;
        
    }
}

// 930. Binary Subarrays With Sum
class Solution {
    public int numSubarraysWithSum(int[] nums, int goal) {
        return atMost(nums, goal) - atMost(nums, goal - 1);
    }

    private int atMost(int[] nums, int goal) {
        if (goal < 0) return 0;

        int l = 0, sum = 0, count = 0;

        for (int r = 0; r < nums.length; r++) {
            sum += nums[r];

            while (sum > goal) {
                sum -= nums[l];
                l++;
            }

            count += (r - l + 1);
        }
        return count;
    }
}

//1248. Count Number of Nice Subarrays
class Solution {
    public int numberOfSubarrays(int[] nums, int k) {
        return atmost(nums , k ) - atmost(nums , k-1);
    }

    private int atmost(int nums [] , int k){
        int l=0 , count = 0, odd= 0 ;

        for(int r =0 ; r<nums.length ; r++){
            if(nums[r] %2 == 1 ) odd++;

            while(odd > k){
                if(nums[l]%2 == 1 ) {odd--;}
                l++;
            }
            count+= (r-l+1);
        }
        return count;
    }
}
