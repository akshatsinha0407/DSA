//h
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    preorder(root ,res);
    return res;
    }
    void preorder(TreeNode root, List<Integer> res){
        if(root == null) return;
        res.add(root.val);
        preorder(root.left,res);
        preorder(root.right,res);
    }   
}
//
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
       List<Integer> res = new ArrayList<>();
       inorder(root,res);
       return res;
    }
    void inorder(TreeNode root, List<Integer> res){
        if(root == null) return;
        inorder(root.left,res);
        res.add(root.val);
        inorder(root.right,res);
    }
}
//
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        postorder(root,res);
        return res;
    }
    void postorder(TreeNode root,List<Integer> res){
        if(root == null) return;
        postorder(root.left,res);
        postorder(root.right,res);
        res.add(root.val);
    }
}
//
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> ans = new ArrayList<>();
        if (root == null) return ans;
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);

        while(!q.isEmpty()){
            int size = q.size();
            List<Integer> level = new ArrayList<>();
            for(int i =0 ;i<size;i++){
                TreeNode node = q.poll();
                level.add(node.val);

                if (node.left != null) q.offer(node.left);
                if (node.right != null) q.offer(node.right);
            }
             ans.add(level);
        }
        return ans;
    }
}
// Iterative approch
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if(root == null) return res;
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while(!stack.isEmpty()){
            TreeNode top = stack.pop();
            res.add(top.val);
            if(top.right != null) stack.push(top.right);
            if(top.left != null) stack.push(top.left);
        }
    return res;
    }
}
//
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        Stack<TreeNode> stk = new Stack<>();
        TreeNode curr = root;
        while(!stk.isEmpty() || curr != null){
            while(curr != null){
                stk.push(curr);
                curr= curr.left;
            }
            curr= stk.pop();
            res.add(curr.val);

            curr = curr.right;
        }
        return res;
    }
}
//
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null) return result;

        Stack<TreeNode> stack1 = new Stack<>();
        Stack<TreeNode> stack2 = new Stack<>();

        stack1.push(root);

        while (!stack1.isEmpty()) {
            TreeNode node = stack1.pop();
            stack2.push(node);

            // Left pehle
            if (node.left != null) {
                stack1.push(node.left);
            }
            // Right baad me
            if (node.right != null) {
                stack1.push(node.right);
            }
        }

        while (!stack2.isEmpty()) {
            result.add(stack2.pop().val);
        }

        return result;
    }
}

//
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        int left = maxDepth(root.left);
        int right = maxDepth(root.right);
        return 1+Math.max(left,right);
    }
}
//
class Solution {
    public boolean isBalanced(TreeNode root) {
        return is(root) !=-1;
    }
    public int is(TreeNode root) {
        if(root == null) return 0;
        int left = is(root.left);
        int right = is(root.right);
        if(left==-1 || right == -1) return -1;
        if(Math.abs(left-right)>1) return -1;

        return 1 + Math.max(left,right);
    }
}
//diameter of BT
class Solution {
    int max = 0 ;

    public int diameterOfBinaryTree(TreeNode root) {
        height(root);
        return max;
    }
    public int height(TreeNode root){
        if(root == null) return 0;

        int left = height(root.left);
        int right = height(root.right);

        max= Math.max(max, left+right);
        return 1+ Math.max(left,right);
    }
}
//
class Solution {
    int maxsum = Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {
        dfs( root);
        return maxsum;
    }
    public int dfs(TreeNode root){
        if (root == null) return 0;
        int left = Math.max(0,dfs(root.left));
        int right = Math.max(0,dfs(root.right));

        int currsum = left+right+root.val;
        maxsum = Math.max(maxsum,currsum);

        return root.val + Math.max(left,right);
    }
}
//
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> res  = new ArrayList<>();
        if(root == null ) return res;
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);
        boolean LtoR = true;

        while(!q.isEmpty()){
            int size = q.size();
            List<Integer> level = new ArrayList<>();
            for(int i =0 ;i<size;i++){
                TreeNode node = q.poll();
                if(LtoR == true){
                    level.add(node.val);
                }else{
                    level.add(0,node.val);
                }
                if(node.left != null) q.offer(node.left);
                 if(node.right != null) q.offer(node.right);
            }
           res.add(level);
           LtoR = !LtoR;
        }
         
            return res;
    }

}




//
class Solution {
    static class Pair {
        Node node;
        int hd;

        Pair(Node node, int hd) {
            this.node = node;
            this.hd = hd;
        }
    }

    static ArrayList<Integer> topView(Node root) {
        ArrayList<Integer> ans = new ArrayList<>();
        if (root == null) return ans;

        TreeMap<Integer, Integer> map = new TreeMap<>();
        Queue<Pair> q = new LinkedList<>();

        q.add(new Pair(root, 0));

        while (!q.isEmpty()) {
            Pair cur = q.poll();
            Node node = cur.node;
            int hd = cur.hd;

            // pehli baar jo HD mile wahi top view
            if (!map.containsKey(hd)) {
                map.put(hd, node.data);
            }

            if (node.left != null)
                q.add(new Pair(node.left, hd - 1));

            if (node.right != null)
                q.add(new Pair(node.right, hd + 1));
        }

        for (int val : map.values()) {
            ans.add(val);
        }

        return ans;
    }
}
//
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> res = new ArrayList<>();
          if (root == null) return res;
        Queue<TreeNode> q = new LinkedList<>();
        q.add(root);
        while(!q.isEmpty()){
            int size = q.size();
            for(int i = 0;i<size;i++){
                TreeNode node = q.poll();
                if(i == size-1){
                    res.add(node.val);
                }
                
                if(node.left != null){
                    q.add(node.left);
                }
                if(node.right != null){
                    q.add(node.right);
                }
            }
        }
        return res;
    }
}
//
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root == null ) return true;
        return isMirror(root.left,root.right);
    }
     public boolean isMirror(TreeNode a, TreeNode b ) {
        if(a == null && b == null) return true;
        if(a == null || b == null) return false;
        if(a.val != b.val) return false;

        return isMirror(a.left,b.right) && isMirror(a.right,b.left);
     }
}
//
import java.util.*;

class Solution {

    public void printRootToGivenNode(TreeNode root, int target) {
        List<Integer> path = new ArrayList<>();

        if (dfs(root, target, path)) {
            System.out.println(path);
        } else {
            System.out.println("Node not found");
        }
    }

    // DFS function jo batata hai: target mila ya nahi
    private boolean dfs(TreeNode node, int target, List<Integer> path) {

        // base case
        if (node == null) return false;

        // current node ko path me add karo
        path.add(node.val);

        // üéØ target mil gaya
        if (node.val == target) {
            return true;
        }

        // left ya right me target mila?
        if (dfs(node.left, target, path) || dfs(node.right, target, path)) {
            return true;
        }

        // ‚ùå target is branch me nahi mila ‚Üí backtrack
        path.remove(path.size() - 1);
        return false;
    }
}
//
import java.util.*;

class Solution {

    // Main function jo root se call hogi
    public void printRootToLeaf(TreeNode root) {
        List<Integer> path = new ArrayList<>();
        dfs(root, path);
    }

    // DFS helper function
    private void dfs(TreeNode node, List<Integer> path) {

        // base case
        if (node == null) return;

        // 1Ô∏è‚É£ current node ko path me add karo
        path.add(node.val);

        // 2Ô∏è‚É£ agar leaf node hai ‚Üí path print karo
        if (node.left == null && node.right == null) {
            System.out.println(path);
        }
        else {
            // 3Ô∏è‚É£ left aur right child ke liye DFS
            dfs(node.left, path);
            dfs(node.right, path);
        }

        // 4Ô∏è‚É£ backtracking (important üî•)
        // wapas jaate waqt current node ko hata do
        path.remove(path.size() - 1);
    }
}
//
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null || root == p || root ==q) return root;
        TreeNode left = lowestCommonAncestor( root.left,  p,  q);
        TreeNode right = lowestCommonAncestor( root.right,  p,  q);
        if(left != null && right != null){
            return root;
        }
        return (left != null) ? left : right;
    }
}
//
class Solution {

    // pair class: node + index
    static class Pair {
        TreeNode node;
        long idx;

        Pair(TreeNode node, long idx) {
            this.node = node;
            this.idx = idx;
        }
    }

    public int widthOfBinaryTree(TreeNode root) {

        if (root == null) return 0;

        Queue<Pair> q = new LinkedList<>();
        q.offer(new Pair(root, 0));

        int ans = 0;

        while (!q.isEmpty()) {

            int size = q.size();
            long first = q.peek().idx;   // leftmost index of level
            long last = first;

            for (int i = 0; i < size; i++) {

                Pair curr = q.poll();

                // normalize index to avoid overflow
                long idx = curr.idx - first;
                last = idx;

                if (curr.node.left != null) {
                    q.offer(new Pair(curr.node.left, 2 * idx));
                }

                if (curr.node.right != null) {
                    q.offer(new Pair(curr.node.right, 2 * idx + 1));
                }
            }

            // width of current level
            ans = Math.max(ans, (int)(last + 1));
        }

        return ans;
    }
}

//
class Solution {

    // parent mapping
    static Map<Node, Node> parent = new HashMap<>();

    public static int minTime(Node root, int target) {

        // step 1: build parent map
        buildParent(root, null);

        // find target node
        Node targetNode = findTarget(root, target);

        // step 2: BFS from target
        Queue<Node> q = new LinkedList<>();
        Set<Node> visited = new HashSet<>();

        q.add(targetNode);
        visited.add(targetNode);

        int time = 0;

        while (!q.isEmpty()) {

            int size = q.size();
            boolean burned = false;

            for (int i = 0; i < size; i++) {
                Node curr = q.poll();

                if (curr.left != null && !visited.contains(curr.left)) {
                    visited.add(curr.left);
                    q.add(curr.left);
                    burned = true;
                }

                if (curr.right != null && !visited.contains(curr.right)) {
                    visited.add(curr.right);
                    q.add(curr.right);
                    burned = true;
                }

                Node par = parent.get(curr);
                if (par != null && !visited.contains(par)) {
                    visited.add(par);
                    q.add(par);
                    burned = true;
                }
            }

            if (burned) time++;
        }

        return time;
    }

    // DFS to store parent
    private static void buildParent(Node node, Node par) {
        if (node == null) return;
        parent.put(node, par);
        buildParent(node.left, node);
        buildParent(node.right, node);
    }

    // DFS to find target node
    private static Node findTarget(Node node, int target) {
        if (node == null) return null;
        if (node.data == target) return node;

        Node left = findTarget(node.left, target);
        if (left != null) return left;

        return findTarget(node.right, target);
    }
}
//
class Solution {
    public int countNodes(TreeNode root) {
        int l = le(root);
        int r = re(root);
        if(l == r){
            return (int)Math.pow(2,l)-1;
        }
        else{
            return 1+ countNodes(root.left)+countNodes(root.right);
        }
    }
    public int le(TreeNode root){
        if(root == null) return 0;
        int dep=0;
        while(root != null){
            root = root.left;
            dep++;
        }
        return dep;
    }
    public int re(TreeNode root){
        if(root == null) return 0;
        int dep=0;
        while(root != null){
            root = root.right;
            dep++;
        }
        return dep;
    }
}

//
class Solution {
    int preidx= 0;
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        return build(preorder , inorder , 0 , inorder.length-1);
    }
    public TreeNode build(int[] preorder, int[] inorder,int inst, int inend) {
        if(inst>inend) return null;
        int rootval = preorder[preidx++];
        TreeNode root = new TreeNode(rootval);
        int mid = inst;
        while(inorder[mid] != rootval){
            mid++;
        }
        root.left = build(preorder, inorder, inst , mid-1);
        root.right = build(preorder, inorder , mid+1 , inend);

        return root;
    }
}
//
class Solution {

    int postIndex;

    public TreeNode buildTree(int[] inorder, int[] postorder) {
        postIndex = postorder.length - 1;
        return build(inorder, postorder, 0, inorder.length - 1);
    }

    private TreeNode build(int[] inorder, int[] postorder, int inStart, int inEnd) {

        if (inStart > inEnd)
            return null;

        int rootVal = postorder[postIndex--];
        TreeNode root = new TreeNode(rootVal);

        int mid = inStart;
        while (inorder[mid] != rootVal) {
            mid++;
        }

        root.right = build(inorder, postorder, mid + 1, inEnd);

        root.left = build(inorder, postorder, inStart, mid - 1);

        return root;
    }
}
//
public class Codec {

    // Serialize tree to string
    public String serialize(TreeNode root) {

        if (root == null) return "";

        StringBuilder sb = new StringBuilder();
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);

        while (!q.isEmpty()) {
            TreeNode node = q.poll();

            if (node == null) {
                sb.append("null,");
                continue;
            }

            sb.append(node.val).append(",");
            q.offer(node.left);
            q.offer(node.right);
        }

        return sb.toString();
    }

    // Deserialize string to tree
    public TreeNode deserialize(String data) {

        if (data == null || data.length() == 0) return null;

        String[] arr = data.split(",");
        TreeNode root = new TreeNode(Integer.parseInt(arr[0]));

        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);

        int i = 1;

        while (!q.isEmpty()) {
            TreeNode parent = q.poll();

            // left child
            if (!arr[i].equals("null")) {
                parent.left = new TreeNode(Integer.parseInt(arr[i]));
                q.offer(parent.left);
            }
            i++;

            // right child
            if (!arr[i].equals("null")) {
                parent.right = new TreeNode(Integer.parseInt(arr[i]));
                q.offer(parent.right);
            }
            i++;
        }

        return root;
    }
}
