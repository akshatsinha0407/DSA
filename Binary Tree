//h
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    preorder(root ,res);
    return res;
    }
    void preorder(TreeNode root, List<Integer> res){
        if(root == null) return;
        res.add(root.val);
        preorder(root.left,res);
        preorder(root.right,res);
    }   
}
//
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
       List<Integer> res = new ArrayList<>();
       inorder(root,res);
       return res;
    }
    void inorder(TreeNode root, List<Integer> res){
        if(root == null) return;
        inorder(root.left,res);
        res.add(root.val);
        inorder(root.right,res);
    }
}
//
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        postorder(root,res);
        return res;
    }
    void postorder(TreeNode root,List<Integer> res){
        if(root == null) return;
        postorder(root.left,res);
        postorder(root.right,res);
        res.add(root.val);
    }
}
//
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> ans = new ArrayList<>();
        if (root == null) return ans;
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);

        while(!q.isEmpty()){
            int size = q.size();
            List<Integer> level = new ArrayList<>();
            for(int i =0 ;i<size;i++){
                TreeNode node = q.poll();
                level.add(node.val);

                if (node.left != null) q.offer(node.left);
                if (node.right != null) q.offer(node.right);
            }
             ans.add(level);
        }
        return ans;
    }
}
// Iterative approch
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if(root == null) return res;
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while(!stack.isEmpty()){
            TreeNode top = stack.pop();
            res.add(top.val);
            if(top.right != null) stack.push(top.right);
            if(top.left != null) stack.push(top.left);
        }
    return res;
    }
}
//
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        Stack<TreeNode> stk = new Stack<>();
        TreeNode curr = root;
        while(!stk.isEmpty() || curr != null){
            while(curr != null){
                stk.push(curr);
                curr= curr.left;
            }
            curr= stk.pop();
            res.add(curr.val);

            curr = curr.right;
        }
        return res;
    }
}
//
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null) return result;

        Stack<TreeNode> stack1 = new Stack<>();
        Stack<TreeNode> stack2 = new Stack<>();

        stack1.push(root);

        while (!stack1.isEmpty()) {
            TreeNode node = stack1.pop();
            stack2.push(node);

            // Left pehle
            if (node.left != null) {
                stack1.push(node.left);
            }
            // Right baad me
            if (node.right != null) {
                stack1.push(node.right);
            }
        }

        while (!stack2.isEmpty()) {
            result.add(stack2.pop().val);
        }

        return result;
    }
}

//
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        int left = maxDepth(root.left);
        int right = maxDepth(root.right);
        return 1+Math.max(left,right);
    }
}
//
class Solution {
    public boolean isBalanced(TreeNode root) {
        return is(root) !=-1;
    }
    public int is(TreeNode root) {
        if(root == null) return 0;
        int left = is(root.left);
        int right = is(root.right);
        if(left==-1 || right == -1) return -1;
        if(Math.abs(left-right)>1) return -1;

        return 1 + Math.max(left,right);
    }
}
//diameter of BT
class Solution {
    int max = 0 ;

    public int diameterOfBinaryTree(TreeNode root) {
        height(root);
        return max;
    }
    public int height(TreeNode root){
        if(root == null) return 0;

        int left = height(root.left);
        int right = height(root.right);

        max= Math.max(max, left+right);
        return 1+ Math.max(left,right);
    }
}
//
class Solution {
    int maxsum = Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {
        dfs( root);
        return maxsum;
    }
    public int dfs(TreeNode root){
        if (root == null) return 0;
        int left = Math.max(0,dfs(root.left));
        int right = Math.max(0,dfs(root.right));

        int currsum = left+right+root.val;
        maxsum = Math.max(maxsum,currsum);

        return root.val + Math.max(left,right);
    }
}
//
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> res  = new ArrayList<>();
        if(root == null ) return res;
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);
        boolean LtoR = true;

        while(!q.isEmpty()){
            int size = q.size();
            List<Integer> level = new ArrayList<>();
            for(int i =0 ;i<size;i++){
                TreeNode node = q.poll();
                if(LtoR == true){
                    level.add(node.val);
                }else{
                    level.add(0,node.val);
                }
                if(node.left != null) q.offer(node.left);
                 if(node.right != null) q.offer(node.right);
            }
           res.add(level);
           LtoR = !LtoR;
        }
         
            return res;
    }

}
//
