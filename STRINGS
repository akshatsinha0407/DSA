//Remove OuterMost Parenthesis
class Solution {
    public String removeOuterParentheses(String s) {
        StringBuilder str = new StringBuilder();
        int count =0;
        for(char ch : s.toCharArray()){
        if(ch == '('){
            if(count>0){
            str.append(ch);
            }
            count++;
        }
        if(ch == ')'){
            count--;
            if(count>0){
            str.append(ch);
            }
        }
        }
        return str.toString();
    }
}

//151. Reverse Words in a String
class Solution {
    public String reverseWords(String s) {
       s= s.trim();
        String words[] = s.split("\\s+");
        StringBuilder str = new StringBuilder();
        for(int i = words.length-1;i>=0;i--){
            str.append(words[i]);
            if(i!=0) str.append(" ");
        }
        return str.toString();
    }
}

// 1903. Largest Odd Number in String
class Solution {
    public String largestOddNumber(String num) {
        for(int i = num.length()-1 ; i>=0 ;i--){
            int digit = num.charAt(i) -'0';
            if(digit%2==1) return num.substring(0,i+1);
        }
        return "";
    }
}
// 14. Longest Common Prefix
class Solution {
    public String longestCommonPrefix(String[] strs) {
        String sample = strs[0];
        for (int i =1 ;i<strs.length ;i++){
            while(!strs[i].startsWith(sample)){
                sample = sample.substring(0,sample.length()-1);
                if(sample.isEmpty())return "";
            }
        }
        return sample;
    }
}
//205. Isomorphic Strings
class Solution {
    public boolean isIsomorphic(String s, String t) {
         //sanity check
    if(s.length() != t.length()) {return false;}
    //map define
    Map<Character, Character> map = new HashMap<>();
    //for loop
    for (int i = 0 ; i <s.length(); i++){
        char og = s.charAt(i);
        char rep = t.charAt(i);
        if(!map.containsKey(og)){
            if(!map.containsValue(rep)){
                map.put(og,rep);
            }
            else{
                return false;
            }
        }
        else{
            char mapped = map.get(og);
            if(mapped != rep) return false;
        }
        }
        return true;
    }
}

//796. Rotate String
class Solution {
    public boolean rotateString(String s, String goal) {
     if(s.length() != goal.length()) return false;
     String temp = s + s;
     return temp.contains(goal);   
    }
}

//242. Valid Anagram
class Solution {
    public boolean isAnagram(String s, String t) {
        if(s.length() != t.length()) return false;

        char arr1[]=s.toCharArray();
        char arr2[]=t.toCharArray();

        Arrays.sort(arr1);
        Arrays.sort(arr2);

        return Arrays.equals(arr1,arr2);
    }
}

// 451. Sort Characters By Frequency
class Solution {
    public String frequencySort(String s) {
        //Map
        Map<Character, Integer> map = new HashMap<>();
        for (char c : s.toCharArray()) {
            map.put(c, map.getOrDefault(c, 0) + 1);
        }
        //Array
        List<Character> arr[] = new List[s.length() + 1];
        for (char c : map.keySet()) {
            int freq = map.get(c);
            if (arr[freq] == null) {
                arr[freq] = new ArrayList<>();
            }
            arr[freq].add(c);
        }
        //printing
        StringBuilder str = new StringBuilder();
        for (int i = arr.length - 1; i > 0; i--) {
            if (arr[i] != null) {
                for (char c : arr[i]) {
                    for (int j = 0; j < i; j++) {
                        str.append(c);
                    }
                }
            }
        }
        return str.toString();

    }
}

//1614. Maximum Nesting Depth of the Parentheses
class Solution {
    public int maxDepth(String s) {
        int depth =0;
        int max= 0;
        for(char ch : s.toCharArray()){
            if(ch == '('){
                depth++;
                max = Math.max(depth,max);

            }
            else if(ch==')'){
                depth--;
            }
        }
        return max;
    }
}
//
