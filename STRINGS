//Remove OuterMost Parenthesis
class Solution {
    public String removeOuterParentheses(String s) {
        StringBuilder str = new StringBuilder();
        int count =0;
        for(char ch : s.toCharArray()){
        if(ch == '('){
            if(count>0){
            str.append(ch);
            }
            count++;
        }
        if(ch == ')'){
            count--;
            if(count>0){
            str.append(ch);
            }
        }
        }
        return str.toString();
    }
}

//151. Reverse Words in a String
class Solution {
    public String reverseWords(String s) {
       s= s.trim();
        String words[] = s.split("\\s+");
        StringBuilder str = new StringBuilder();
        for(int i = words.length-1;i>=0;i--){
            str.append(words[i]);
            if(i!=0) str.append(" ");
        }
        return str.toString();
    }
}

// 1903. Largest Odd Number in String
class Solution {
    public String largestOddNumber(String num) {
        for(int i = num.length()-1 ; i>=0 ;i--){
            int digit = num.charAt(i) -'0';
            if(digit%2==1) return num.substring(0,i+1);
        }
        return "";
    }
}
// 14. Longest Common Prefix
class Solution {
    public String longestCommonPrefix(String[] strs) {
        String sample = strs[0];
        for (int i =1 ;i<strs.length ;i++){
            while(!strs[i].startsWith(sample)){
                sample = sample.substring(0,sample.length()-1);
                if(sample.isEmpty())return "";
            }
        }
        return sample;
    }
}
//205. Isomorphic Strings
class Solution {
    public boolean isIsomorphic(String s, String t) {
         //sanity check
    if(s.length() != t.length()) {return false;}
    //map define
    Map<Character, Character> map = new HashMap<>();
    //for loop
    for (int i = 0 ; i <s.length(); i++){
        char og = s.charAt(i);
        char rep = t.charAt(i);
        if(!map.containsKey(og)){
            if(!map.containsValue(rep)){
                map.put(og,rep);
            }
            else{
                return false;
            }
        }
        else{
            char mapped = map.get(og);
            if(mapped != rep) return false;
        }
        }
        return true;
    }
}

//796. Rotate String
class Solution {
    public boolean rotateString(String s, String goal) {
     if(s.length() != goal.length()) return false;
     String temp = s + s;
     return temp.contains(goal);   
    }
}

//242. Valid Anagram
class Solution {
    public boolean isAnagram(String s, String t) {
        if(s.length() != t.length()) return false;

        char arr1[]=s.toCharArray();
        char arr2[]=t.toCharArray();

        Arrays.sort(arr1);
        Arrays.sort(arr2);

        return Arrays.equals(arr1,arr2);
    }
}

// 451. Sort Characters By Frequency
class Solution {
    public String frequencySort(String s) {
        //Map
        Map<Character, Integer> map = new HashMap<>();
        for (char c : s.toCharArray()) {
            map.put(c, map.getOrDefault(c, 0) + 1);
        }
        //Array
        List<Character> arr[] = new List[s.length() + 1];
        for (char c : map.keySet()) {
            int freq = map.get(c);
            if (arr[freq] == null) {
                arr[freq] = new ArrayList<>();
            }
            arr[freq].add(c);
        }
        //printing
        StringBuilder str = new StringBuilder();
        for (int i = arr.length - 1; i > 0; i--) {
            if (arr[i] != null) {
                for (char c : arr[i]) {
                    for (int j = 0; j < i; j++) {
                        str.append(c);
                    }
                }
            }
        }
        return str.toString();

    }
}

//1614. Maximum Nesting Depth of the Parentheses
class Solution {
    public int maxDepth(String s) {
        int depth =0;
        int max= 0;
        for(char ch : s.toCharArray()){
            if(ch == '('){
                depth++;
                max = Math.max(depth,max);

            }
            else if(ch==')'){
                depth--;
            }
        }
        return max;
    }
}
//13. Roman to Integer
class Solution {
    public int romanToInt(String s) {
        Map<Character,Integer> map = new HashMap<>();
        map.put('I',1);
        map.put('V',5);
        map.put('X',10);
        map.put('L',50);
        map.put('C',100);
        map.put('D',500);
        map.put('M',1000);
        int sum=0;

        for(int i=0 ; i<s.length();i++){
            int curr = map.get(s.charAt(i));
            if(i+1 < s.length() && curr < map.get(s.charAt(i+1)) ){
                sum -= curr;
            }
            else{
                sum += curr ;
            }
        }
        return sum;
    }
}
//7. Reverse Integer
class Solution {
    public int reverse(int x) {
        int rev =0;
        while(x !=0 ){
            int digit = x %10;
            x = x/10;

            if(rev > Integer.MAX_VALUE/10 || (rev == Integer.MAX_VALUE && digit >7)){
                return 0;
            }

             if(rev < Integer.MIN_VALUE/10 || (rev == Integer.MIN_VALUE && digit < -8)){
                return 0;
            }

            rev = rev*10 + digit;
        }
        return rev;
    }
}

//8. String to Integer (atoi)
class Solution {
    public int myAtoi(String s) {
        //leading space
        int i=0; 
        int n = s.length();
        while(i<n && s.charAt(i)==' '){
         i++;
        }
        // sign
        int sign = 1;
        if(i < n && ( s.charAt(i)=='+'||s.charAt(i)=='-')){
            if(s.charAt(i) == '-') sign = -1;
            i++;
        }
        //convert
        long result =0;
        while(i<n && Character.isDigit(s.charAt(i))){
            result = result*10 +(s.charAt(i)-'0');
         // overflow
         if(result * sign > Integer.MAX_VALUE) return Integer.MAX_VALUE;
         if(result * sign < Integer.MIN_VALUE) return Integer.MIN_VALUE;

         i++;
        }
        return (int)(result * sign);

    }
}

// 5 longest Palindromic Substring
class Solution {
    public String longestPalindrome(String s) {
        if(s==null||s.length()==0) return "";
        int st=0,end=0;
        for(int i=0;i<s.length();i++){
            int l1=expand(s,i,i);
            int l2=expand(s,i,i+1);
            int l= Math.max(l1,l2);
            if(l>end-st){
                st=i-(l-1)/2;
                end = i + l/2;
            }
        }
        return s.substring(st,end+1);
    }
    private int expand(String s, int l ,int r){
        while(l>=0 && r<s.length() && s.charAt(l)==s.charAt(r)){
            l--;
            r++;
        }
        return (r-l-1);
    }
}

//
