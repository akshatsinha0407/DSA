// Check for balanced paranthesis
class Solution {
    public boolean isValid(String s) {
         Stack<Character> st = new Stack<>();
        for(char ch : s.toCharArray()){
            if(ch=='(' || ch=='[' || ch=='{'){
                st.push(ch);
            }
            else{
                if(st.isEmpty()) return false;
                char top =st.pop();
                if ((ch == ')' && top != '(') ||
                    (ch == '}' && top != '{') ||
                    (ch == ']' && top != '[')) {
                    return false;
                }
            }
        }
        {
            if(!st.isEmpty()) return false;
        }
        return true;
    }
}
// Implement Min Stack
class MinStack {
    Stack<Integer> actual;
    Stack<Integer> min;
    public MinStack() {
        actual = new Stack<>();
        min = new Stack<>();
    }
    
    public void push(int val) {
        actual.push(val);
        if(min.isEmpty() || val<=min.peek()){
            min.push(val);
        }
    }
    
    public void pop() {
        int popped = actual.pop();
        if(popped == min.peek()){
            min.pop();
        }
    }
    
    public int top() {
      return  actual.peek();
    }
    
    public int getMin() {
        return min.peek();
    }
}
//496. Next Greater Element I
class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        Map<Integer ,Integer> map = new HashMap<>();
        Stack<Integer> stk = new Stack<>();
        for(int i = nums2.length-1 ; i>=0 ; i--){
            int curr = nums2[i];
            while(!stk.isEmpty() && curr >= stk.peek() ){
                stk.pop();
            }
            int nge = stk.isEmpty() ? -1 : stk.peek() ;
            map.put(curr,nge);
            stk.push(curr);
        }
        int res [] =new int [nums1.length];
        for(int i = 0 ; i< nums1.length ;i++){
            res[i]=map.get(nums1[i]);
        }
        return res;
    }
    }
