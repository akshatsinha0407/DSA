// Check for balanced paranthesis
class Solution {
    public boolean isValid(String s) {
         Stack<Character> st = new Stack<>();
        for(char ch : s.toCharArray()){
            if(ch=='(' || ch=='[' || ch=='{'){
                st.push(ch);
            }
            else{
                if(st.isEmpty()) return false;
                char top =st.pop();
                if ((ch == ')' && top != '(') ||
                    (ch == '}' && top != '{') ||
                    (ch == ']' && top != '[')) {
                    return false;
                }
            }
        }
        {
            if(!st.isEmpty()) return false;
        }
        return true;
    }
}
// Implement Min Stack
class MinStack {
    Stack<Integer> actual;
    Stack<Integer> min;
    public MinStack() {
        actual = new Stack<>();
        min = new Stack<>();
    }
    
    public void push(int val) {
        actual.push(val);
        if(min.isEmpty() || val<=min.peek()){
            min.push(val);
        }
    }
    
    public void pop() {
        int popped = actual.pop();
        if(popped == min.peek()){
            min.pop();
        }
    }
    
    public int top() {
      return  actual.peek();
    }
    
    public int getMin() {
        return min.peek();
    }
}
//496. Next Greater Element I
class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        Map<Integer ,Integer> map = new HashMap<>();
        Stack<Integer> stk = new Stack<>();
        for(int i = nums2.length-1 ; i>=0 ; i--){
            int curr = nums2[i];
            while(!stk.isEmpty() && curr >= stk.peek() ){
                stk.pop();
            }
            int nge = stk.isEmpty() ? -1 : stk.peek() ;
            map.put(curr,nge);
            stk.push(curr);
        }
        int res [] =new int [nums1.length];
        for(int i = 0 ; i< nums1.length ;i++){
            res[i]=map.get(nums1[i]);
        }
        return res;
    }
    }
// 503. Next Greater Element II
class Solution {
    public int[] nextGreaterElements(int[] nums) {
        int n = nums.length;
        int res[] =new int [n];
        Stack<Integer> stk = new Stack<>();
        for(int i = 2*n-1 ; i>=0 ;i--){
            int curr = nums[i%n];
            while(!stk.isEmpty() && curr>=stk.peek()){
                stk.pop();
            }
            if(i<n){
                 res[i] = stk.isEmpty() ? -1 : stk.peek();
            }
            stk.push(curr);
        }
        return res;
    }
}
//nextSmallerEle
class Solution {
    static ArrayList<Integer> nextSmallerEle(int[] arr) {

        ArrayList<Integer> ans = new ArrayList<>();
        Stack<Integer> stk = new Stack<>();

      
        for (int i = arr.length - 1; i >= 0; i--) {
            int curr = arr[i];

         
            while (!stk.isEmpty() && curr <= stk.peek()) {
                stk.pop();
            }

            int res = stk.isEmpty() ? -1 : stk.peek();
            ans.add(res);      

            stk.push(curr);
        }

       )
        Collections.reverse(ans);
        return ans;
    }
}


// prevSmaller
class Solution {
    public static ArrayList<Integer> prevSmaller(int[] arr) {
        ArrayList<Integer> ans = new ArrayList<>();
        Stack<Integer> stk = new Stack<>();

        for (int i = 0; i < arr.length; i++) {
            int curr = arr[i];

            while (!stk.isEmpty() && curr <= stk.peek()) {
                stk.pop();
            }

            int prev = stk.isEmpty() ? -1 : stk.peek();
            ans.add(prev);

            stk.push(curr);
        }
        return ans;
    }
}
//Trapping Rain Water
class Solution {
    public int trap(int[] height) {
        int lmax =0 ,rmax=0, total =0 , l=0 ,r=height.length -1 ;
        while(l<r){
            if(height[l]<=height[r]){
                if(lmax > height[l]){
                    total += lmax - height[l];
                }
                else{
                    lmax=height[l];
                }
                l =l+1;
            }
            else{
                if(rmax > height[r]){
                    total += rmax - height[r];
                }
                else{
                    rmax=height[r];
                }
                r=r-1;
            }
        }
        return total;
    }
}
// by stack
import java.util.Stack;

class Solution {
    public int trap(int[] height) {
        Stack<Integer> st = new Stack<>();
        int total = 0;

        for (int i = 0; i < height.length; i++) {

            // jab current height badi ho
            while (!st.isEmpty() && height[i] > height[st.peek()]) {

                int bottom = st.pop();   // valley

                // agar left boundary hi nahi bachi
                if (st.isEmpty()) break;

                int left = st.peek();    // left boundary

                int width = i - left - 1;
                int h = Math.min(height[left], height[i]) - height[bottom];

                total += width * h;
            }

            // choti ya equal height ho to push
            st.push(i);
        }

        return total;
    }
}

//907. Sum of Subarray Minimums
class Solution {
    public int sumSubarrayMins(int[] arr) {
        long mod = 10000000007L;
        int n = arr.length;
        int []nge = new int[n];
        int []pse = new int[n];
        Stack<Integer> stk = new Stack<>();
        //pse
        for(int i = 0 ; i< n ;i++){
            while(!stk.isEmpty() && stk.peek() > arr[i]){
                stk.pop();
            }
            pse[i]= stk.isEmpty() ? -1 : stk.peek();
            stk.push(i);
        }
        stk.clear();
        //nge
        for(int i = n-1 ; i>=0 ;i--){
            while(!stk.isEmpty() && stk.peek() >= arr[i]){
                stk.pop();
            }
            nge[i] = stk.isEmpty() ? n : stk.peek() ;
            stk.push(i);
        }
        //calcu 
        long ans = 0 ;
        for(int i = 0 ; i < n ; i++){
            int left = i - pse[i];
            int right = nge[i] - i ;
           ans = (ans + (left * right * arr[i] )) % mod;
        }
        return (int) ans;
    }
}

//asteroidCollision
class Solution {
    public int[] asteroidCollision(int[] asteroids) {
        Stack<Integer> stk = new Stack<>();
        for(int curr : asteroids){
            boolean distroy = false;
            while(!stk.isEmpty() && curr <0 && stk.peek() >0 ){
                if(Math.abs(curr) > Math.abs(stk.peek())){
                    stk.pop();
                    continue;
                }
                else if(Math.abs(curr) ==  Math.abs(stk.peek())){
                    stk.pop();
                }
                
                    distroy= true;
                    break;
                
            }

            if(!distroy){
                stk.push(curr);
            }

        }
        int res[] = new int[stk.size()];
        for(int i = stk.size()-1 ; i >= 0 ; i--){
            res[i] =stk.pop();
        }
        return res ;
    }
}

// subArrayRanges
import java.util.Stack;

class Solution {

    public long subArrayRanges(int[] nums) {
        long maxSub = maxSub(nums);
        long minSub = minSub(nums);
        return maxSub - minSub;
    }


    private long minSub(int[] nums) {
        Stack<Integer> stk = new Stack<>();
        int n = nums.length;
        long sum = 0;

        for (int i = 0; i <= n; i++) {
            int curr = (i == n) ? Integer.MIN_VALUE : nums[i];

            while (!stk.isEmpty() && nums[stk.peek()] > curr) {
                int mid = stk.pop();
                int left = stk.isEmpty() ? -1 : stk.peek();
                int right = i;

                long count = (long)(mid - left) * (right - mid);
                sum += count * nums[mid];
            }
            stk.push(i);
        }
        return sum;
    }

    private long maxSub(int[] nums) {
        Stack<Integer> stk = new Stack<>();
        int n = nums.length;
        long sum = 0;

        for (int i = 0; i <= n; i++) {
            int curr = (i == n) ? Integer.MAX_VALUE : nums[i];

            while (!stk.isEmpty() && nums[stk.peek()] < curr) {
                int mid = stk.pop();
                int left = stk.isEmpty() ? -1 : stk.peek();
                int right = i;

                long count = (long)(mid - left) * (right - mid);
                sum += count * nums[mid];
            }
            stk.push(i);
        }
        return sum;
    }
}

// removeKdigits
class Solution {
    public String removeKdigits(String num, int k) {
     Stack<Character> stk = new Stack<>();
     for(char ch : num.toCharArray()){
        // normal
        while(!stk.isEmpty() && k>0 && stk.peek() > ch){
            stk.pop();
            k--;
        }
        stk.push(ch);
     }
     // 12345
     while(!stk.isEmpty() && k>0 ){
        stk.pop();
        k--;
     }
     //SB
     StringBuilder sb = new StringBuilder();
      while (!stk.isEmpty()) {
            sb.append(stk.pop());
        }
     sb.reverse();
        int i = 0;
        while (i < sb.length() && sb.charAt(i) == '0') {
            i++;
        }

        String ans = sb.substring(i);
        return ans.length() == 0 ? "0" : ans;
    }
}

//largestRectangleArea
import java.util.Stack;

class Solution {
    public int largestRectangleArea(int[] heights) {
        Stack<Integer> st = new Stack<>();
        int n = heights.length;
        int maxArea = 0;

        // i == n ek dummy bar (height = 0) jaisa behave karega
        for (int i = 0; i <= n; i++) {

            int currHeight = (i == n) ? 0 : heights[i];

            // Jab tak stack ka top current se bada hai
            while (!st.isEmpty() && heights[st.peek()] > currHeight) {

                int height = heights[st.pop()];

                // left boundary
                int right = i;
                int left = st.isEmpty() ? -1 : st.peek();

                int width = right - left - 1;
                int area = height * width;

                maxArea = Math.max(maxArea, area);
            }

            st.push(i);
        }

        return maxArea;
    }
}
