// Assign Cookies
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(g);
        Arrays.sort(s);
        int i=0 , j=0 ,count=0;
        while(i<g.length && j<s.length){
            if(g[i]<=s[j]){
                i++;
                j++;
                count++;
            }
            else{
                j++;
            }
        }
        return count;
    }
}
//
class Solution {

    double fractionalKnapsack(int W, int[] value, int[] weight, int n) {

        double[] ratio = new double[n];
        for (int i = 0; i < n; i++) {
            ratio[i] = (double) value[i] / weight[i];
        }

        double totalValue = 0.0;
        int capacity = W;

        while (capacity > 0) {

            int maxIndex = -1;
            double maxRatio = 0;

            for (int i = 0; i < n; i++) {
                if (ratio[i] > maxRatio) {
                    maxRatio = ratio[i];
                    maxIndex = i;
                }
            }

            if (maxIndex == -1) break;

            if (weight[maxIndex] <= capacity) {
                totalValue += value[maxIndex];
                capacity -= weight[maxIndex];
            } else {
                totalValue += maxRatio * capacity;
                capacity = 0;
            }

            ratio[maxIndex] = 0;
        }

        return totalValue;
    }
}
//minCoins
class Solution {
    public int minCoins(int[] coins, int amount) {

        int count = 0;

        for (int i = coins.length - 1; i >= 0; i--) {
            while (amount >= coins[i]) {
                amount -= coins[i];
                count++;
            }
        }

        return count;
    }
}

// lemonadeChange
class Solution {
    public boolean lemonadeChange(int[] bills) {
        int five =0 , ten =0;
        for(int num : bills){
            if(num== 5){
                five++;
            }
            else if(num == 10){
                if(five == 0) return false;
                ten++;
                five--;
            }
            else{
                if(ten>0 && five >0){
                    ten--;
                    five--;
                }
                else if(five>=3){
                    five-=3;
                }
                else{
                    return false;
                }
            }
        }
        return true;
    }
}
//checkValidString ()*
class Solution {
    public boolean checkValidString(String s) {
    int min = 0 ,max =0;
    for(char ch : s.toCharArray()){
        if(ch=='('){
            min++;
            max++;
        }
        else if(ch == ')'){
            min--;
            max--;
        }
        else{
            min--;
            max++;
        }
        if(max<0)return false;
        if (min<0) min =0;
    
    }    
    return min == 0;
    }
}
//
class Solution {
    public boolean canJump(int[] nums) {
        int flag = nums.length-1;
        for(int i=nums.length -2 ; i>=0 ; i--){
            if((i + nums[i]) >= flag){
                flag = i;
            }
        }
        return flag == 0;
    }
}
//
class Solution {
    public int jump(int[] nums) {
        int jump =0, destination=nums.length-1 , lastjumpidx =0, flag=0;
        if(nums.length == 1) return 0;
        for(int i =0 ; i<nums.length;i++){
            flag = Math.max(flag, nums[i]+i);

            if(lastjumpidx == i){
                lastjumpidx = flag;
                jump++;
                if(destination <= flag){
                    return jump;
                }
            }
        }
        return jump;
    }
}
//
class Solution {
    public int candy(int[] ratings) {
        int n = ratings.length;
        int candy [] = new int[n];
        Arrays.fill(candy,1);
        //L R
        for(int i = 1 ;i<n ;i++){
            if(ratings[i]>ratings[i-1]){
                candy[i]= candy[i-1]+1;
            }
        }
        //R L
        for(int i = n-2 ;i>=0 ;i--){
            if(ratings[i]>ratings[i+1]){
                candy[i]= Math.max(candy[i+1]+1,candy[i]);
            }
        }
        int sum=0;
        for(int c : candy){
            sum+=c;
        }
        return sum;
    }
}
//
class Solution {
    public int[][] insert(int[][] intervals, int[] newInterval) {
        List<int[]> res = new ArrayList<>();
        int i =0;
        int n = intervals.length;
        while(i<n && intervals[i][1]<newInterval[0]){
            res.add(intervals[i]);
            i++;
        };
        while(i<n && intervals[i][0]<=newInterval[1]){
            newInterval[0]=Math.min(newInterval[0],intervals[i][0]);
            newInterval[1]=Math.max(newInterval[1],intervals[i][1]);
            i++;
        }
        res.add(newInterval);
        while(i<n){
            res.add(intervals[i]);
            i++;
        }
        return res.toArray(new int[res.size()][]);
    }
}
//
class Solution {
    public int[][] merge(int[][] intervals) {
        if(intervals.length == 0) return new int [0][0];
        Arrays.sort(intervals,(a,b)->a[0]-b[0]);
        List<int[]> res = new ArrayList<>();
        res.add(intervals[0]);
        for(int i = 1; i<intervals.length ;i++){
            int [] last = res.get(res.size()-1);
            int[] curr = intervals[i];
            
            if(curr[0] <= last[1]){
                last[1]= Math.max(curr[1] , last[1]);
            }
            else{
                res.add(curr);
            }
        }
        return res.toArray(new int[res.size()][]);
    }
}
//
class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        if(intervals.length == 0) return 0;
        Arrays.sort(intervals,(a,b)->a[1]-b[1]);
        int last = intervals[0][1];
        int count =0;
        for(int i=1 ; i< intervals.length ; i++){
            if(intervals[i][0]<last){
                count++;
            }
            else{
                last = intervals[i][1];
            }
        }
        return count;
    }
}
